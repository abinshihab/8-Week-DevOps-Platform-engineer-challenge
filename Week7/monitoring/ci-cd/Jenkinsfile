pipeline {
    agent any

    parameters {
        choice(name: 'TARGET_ENV', choices: ['dev', 'stage', 'prod'], description: 'Select the deployment environment')
        booleanParam(name: 'APPLY_INFRA',   defaultValue: false, description: '‚úÖ Apply Terraform changes automatically')
        booleanParam(name: 'DESTROY_INFRA', defaultValue: false, description: 'üí£ Destroy monitoring stack for selected environment')
        booleanParam(name: 'ROLLBACK_ON_FAILURE', defaultValue: true, description: 'üîÅ Rollback monitoring stack if apply fails')
    }

    environment {
        ENV                   = "${params.TARGET_ENV}"
        TF_DIR                = "${WORKSPACE}/Week7/monitoring"
        TF_VAR_FILE           = "envs/${ENV}/${ENV}.tfvars"
        AWS_REGION            = "us-east-1"

        // macOS Homebrew Jenkins correct caching path
        TF_PLUGIN_CACHE_DIR   = "${env.JENKINS_HOME}/.terraform.d/plugin-cache"
    }

    options {
        timestamps()
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    stages {

        stage('Checkout SCM') {
            steps {
                echo "üîÑ Checking out source code..."
                checkout scm
            }
        }

        stage('Debug Workspace') {
            steps {
                echo "üîç Checking workspace contents before Terraform..."
                sh '''
echo "----- DEBUG INFO -----"
echo "Current directory:"
pwd
echo ""
echo "Listing .tfvars files:"
find . -type f -name "*.tfvars" || echo "‚ùå No tfvars files found"
echo ""
echo "Listing Week7/monitoring folder:"
ls -R Week7/monitoring || echo "Folder not found!"
echo "-----------------------"
'''
            }
        }

        stage('Prepare Terraform Plugin Cache') {
            steps {
                echo "üì¶ Preparing Terraform plugin cache directory (macOS-safe)..."
                sh """
mkdir -p "${JENKINS_HOME}/.terraform.d/plugin-cache"
chmod -R 777 "${JENKINS_HOME}/.terraform.d/plugin-cache"
echo "TF Plugin Cache Directory Ready: ${TF_PLUGIN_CACHE_DIR}"
"""
            }
        }

        stage('Terraform Init') {
            steps {
                echo "üöÄ Initializing Terraform backend for ${ENV}"
                sh """
export TF_PLUGIN_CACHE_DIR="${TF_PLUGIN_CACHE_DIR}"
echo "[INFO] TF Plugin Cache: ${TF_PLUGIN_CACHE_DIR}"

terraform -chdir="${TF_DIR}" init -reconfigure -input=false \
  -backend-config=envs/${ENV}/backend.conf \
  -backend-config=key=terraform-monitoring/${ENV}/terraform.tfstate \
  -var-file="${TF_VAR_FILE}"
"""
            }
        }

        stage('Terraform Validate') {
            when { expression { !params.DESTROY_INFRA } }
            steps {
                echo "‚úÖ Validating Terraform configuration..."
                sh "terraform -chdir='${TF_DIR}' validate"
            }
        }

        stage('Terraform Plan') {
            when { expression { !params.DESTROY_INFRA } }
            steps {
                echo "üìã Creating Terraform plan for monitoring stack in ${ENV}..."
                sh """
terraform -chdir="${TF_DIR}" plan -input=false \
  -var-file="${TF_VAR_FILE}" \
  -out=tfplan

terraform -chdir="${TF_DIR}" show -no-color tfplan > ${TF_DIR}/tfplan.txt
"""
                archiveArtifacts artifacts: 'Week7/monitoring/tfplan.txt', fingerprint: true
            }
        }

        stage('Manual Approval (PROD only)') {
            when {
                allOf {
                    expression { params.TARGET_ENV == 'prod' }
                    expression { !params.DESTROY_INFRA }
                }
            }
            steps {
                input message: "‚ö†Ô∏è Approve deployment to *PROD Monitoring* environment?", ok: "Deploy"
            }
        }

        stage('Terraform Apply') {
            when {
                allOf {
                    expression { params.APPLY_INFRA }
                    expression { !params.DESTROY_INFRA }
                }
            }
            steps {
                echo "‚ö° Applying Terraform monitoring stack for ${ENV}..."
                script {
                    def applyStatus = sh(script: "terraform -chdir='${TF_DIR}' apply -input=false tfplan", returnStatus: true)
                    if (applyStatus != 0) {
                        echo "‚ùå Terraform apply failed for ${ENV}"
                        if (params.ROLLBACK_ON_FAILURE) {
                            echo "üîÅ Rolling back monitoring resources for ${ENV}..."
                            sh "terraform -chdir='${TF_DIR}' destroy -auto-approve -var-file='${TF_VAR_FILE}'"
                            notifySlack("‚ö†Ô∏è Rollback triggered for *${ENV}* monitoring stack after failed apply")
                        }
                        error("Terraform apply failed with exit code ${applyStatus}")
                    }
                }
            }
        }

        /* üî• NEW ‚Äî Health Check Stage */
        stage('Monitoring Health Check') {
            when {
                allOf {
                    expression { params.APPLY_INFRA }
                    expression { !params.DESTROY_INFRA }
                }
            }
            steps {
                echo "ü©∫ Running monitoring health checks for ${ENV}..."
                sh """
echo "Checking CloudWatch log groups..."
aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/data_agent_${ENV}" --region ${AWS_REGION}
aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/action_agent_${ENV}" --region ${AWS_REGION}

echo "Checking CloudWatch alarms..."
aws cloudwatch describe-alarms --alarm-name-prefix "monitoring-${ENV}" --region ${AWS_REGION}

echo "Checking S3 monitoring folder..."
aws s3 ls s3://cc8weeks-monitoring-${ENV}/ || echo "‚ö†Ô∏è Monitoring S3 bucket empty or missing"
"""
                notifySlack("ü©∫ Monitoring Health Check completed for *${ENV}* ‚Äî dashboards & agents verified")
            }
        }

        /* üî• NEW ‚Äî Export Dashboard URL */
        stage('Export CloudWatch Dashboard URL') {
            when {
                allOf {
                    expression { params.APPLY_INFRA }
                    expression { !params.DESTROY_INFRA }
                }
            }
            steps {
                echo "üìä Exporting CloudWatch dashboard URL for ${ENV}..."

                script {
                    def dashboardName = "monitoring-${ENV}"
                    def dashboardUrl = "https://${AWS_REGION}.console.aws.amazon.com/cloudwatch/home?region=${AWS_REGION}#dashboards:name=${dashboardName}"

                    echo "Dashboard URL: ${dashboardUrl}"
                    notifySlack("üìä CloudWatch Dashboard for *${ENV}*: ${dashboardUrl}")
                }
            }
        }

        /* üî• NEW ‚Äî AI Summary Stage */
        stage('Generate AI Monitoring Summary') {
            when {
                allOf {
                    expression { params.APPLY_INFRA }
                    expression { !params.DESTROY_INFRA }
                }
            }
            steps {
                echo "ü§ñ Generating AI-ready monitoring summary for ${ENV}..."
                sh """
aws lambda invoke \
  --function-name data_agent_${ENV} \
  --region ${AWS_REGION} \
  /dev/null
"""
                notifySlack("ü§ñ AI Monitoring Summary updated for *${ENV}* ‚Äî ready for Week 8 scaling agent")
            }
        }

        /* üî• NEW ‚Äî Auto Promotion: DEV ‚Üí STAGE */
        stage('Auto Promote: DEV ‚Üí STAGE') {
            when {
                allOf {
                    expression { params.TARGET_ENV == 'dev' }
                    expression { params.APPLY_INFRA }
                }
            }
            steps {
                echo "üöÄ Auto-promoting DEV ‚Üí STAGE‚Ä¶"
                build job: env.JOB_NAME,
                    parameters: [
                        string(name: 'TARGET_ENV', value: 'stage'),
                        booleanParam(name: 'APPLY_INFRA', value: true),
                        booleanParam(name: 'DESTROY_INFRA', value: false),
                        booleanParam(name: 'ROLLBACK_ON_FAILURE', value: true)
                    ],
                    wait: true
            }
        }

        /* üî• NEW ‚Äî STAGE ‚Üí PROD (Manual Approval) */
        stage('Promote STAGE ‚Üí PROD (Approval)') {
            when {
                expression { params.TARGET_ENV == 'stage' }
            }
            steps {
                input message: "‚ö†Ô∏è Promote monitoring stack from STAGE ‚Üí PROD?"
                echo "üöÄ Deploying STAGE ‚Üí PROD‚Ä¶"
                build job: env.JOB_NAME,
                    parameters: [
                        string(name: 'TARGET_ENV', value: 'prod'),
                        booleanParam(name: 'APPLY_INFRA', value: true),
                        booleanParam(name: 'DESTROY_INFRA', value: false),
                        booleanParam(name: 'ROLLBACK_ON_FAILURE', value: true)
                    ],
                    wait: true
            }
        }

        stage('Terraform Destroy') {
            when { expression { params.DESTROY_INFRA } }
            steps {
                input message: "üí£ Confirm destroy of *${ENV}* monitoring environment?", ok: "Yes, destroy it!"
                echo "üî• Destroying Terraform monitoring resources for ${ENV}..."
                sh "terraform -chdir='${TF_DIR}' destroy -auto-approve -var-file='${TF_VAR_FILE}'"
            }
        }
    }

    post {
        success {
            echo "‚úÖ Monitoring pipeline completed successfully for ${ENV}"
            script { notifySlack("‚úÖ Terraform Monitoring Apply succeeded for *${ENV}*") }
        }
        failure {
            echo "‚ùå Monitoring pipeline failed for ${ENV}"
            script { notifySlack("‚ùå Terraform Monitoring Pipeline failed for *${ENV}*") }
        }
        always {
            echo "üì¶ Archiving plan and cleaning workspace..."
            archiveArtifacts artifacts: "Week7/monitoring/tfplan.txt", fingerprint: true, allowEmptyArchive: true
            cleanWs(deleteDirs: true)
        }
    }
}

/** Slack Notification Helper */
def notifySlack(String message) {
    try {
        withCredentials([string(credentialsId: 'slack_webhook_url', variable: 'slack_url')]) {
            sh """
curl -X POST -H 'Content-type: application/json' \
--data '{\"text\": \"${message} - Job: ${env.JOB_NAME} #${env.BUILD_NUMBER}\"}' \
\"\${slack_url}\"
"""
        }
    } catch (err) {
        echo "‚ÑπÔ∏è Slack webhook not configured; skipping notification."
    }
}
