pipeline {
    agent any

    parameters {
        choice(
            name: 'TARGET_ENV',
            choices: ['dev', 'stage', 'prod'],
            description: 'üåç Choose deployment environment'
        )
        booleanParam(name: 'APPLY_INFRA', defaultValue: false, description: '‚ö° Apply Terraform changes')
        booleanParam(name: 'DESTROY_INFRA', defaultValue: false, description: 'üí£ Destroy environment')
        booleanParam(name: 'ROLLBACK_ON_FAILURE', defaultValue: true, description: 'üîÅ Rollback on failed apply')
    }

    environment {
        ENV         = "${params.TARGET_ENV}"
        TF_DIR      = "${WORKSPACE}/Week6"
        TF_VAR_FILE = "envs/${ENV}/${ENV}.tfvars"
        TF_BACKEND  = "envs/${ENV}/backend.conf"
        INFRACOST_API_KEY = credentials('infracost_api_key')
    }

    options {
        timestamps()
        disableConcurrentBuilds()
    }

    stages {

        stage('üì¶ Checkout Code') {
            steps {
                echo 'üîÑ Pulling latest code...'
                checkout scm
            }
        }

        stage('üß™ Code Quality Checks (Parallel)') {
            when { expression { !params.DESTROY_INFRA } }
            parallel {
                stage('üßπ terraform fmt') {
                    steps {
                        dir("${TF_DIR}") {
                            sh "terraform fmt -recursive -check || true"
                        }
                    }
                }
                stage('üîç tfsec') {
                    steps {
                        dir("${TF_DIR}") {
                            sh "tfsec . || true"
                        }
                    }
                }
                stage('üß∞ tflint') {
                    steps {
                        dir("${TF_DIR}") {
                            sh "tflint || true"
                        }
                    }
                }
            }
        }

        stage('üöÄ Terraform Init') {
            steps {
                dir("${TF_DIR}") {
                    echo "üß© Terraform init for ${ENV}"
                    sh """
                        rm -rf .terraform .terraform.lock.hcl
                        terraform init -reconfigure -input=false \
                            -backend-config=${TF_BACKEND}
                    """
                }
            }
        }

        stage('üîé Terraform Validate') {
            when { expression { !params.DESTROY_INFRA } }
            steps {
                dir("${TF_DIR}") {
                    sh "terraform validate"
                }
            }
        }

        stage('üìù Terraform Plan') {
            when { expression { !params.DESTROY_INFRA } }
            steps {
                dir("${TF_DIR}") {
                    echo "üõ† Creating plan..."
                    sh """
                        terraform plan -input=false \
                            -var-file=${TF_VAR_FILE} \
                            -out=tfplan

                        terraform show -no-color tfplan > tfplan.txt
                    """
                    archiveArtifacts artifacts: 'tfplan.txt', fingerprint: true
                }
            }
        }

        stage('üí∏ Infracost') {
            when { expression { !params.DESTROY_INFRA } }
            steps {
                dir("${TF_DIR}") {
                    sh """
                        infracost breakdown \
                            --path tfplan \
                            --format json \
                            --out-file infracost.json

                        infracost output \
                            --format table \
                            --path infracost.json > infracost.txt
                    """
                    archiveArtifacts artifacts: 'infracost.txt', fingerprint: true

                    script {
                        def costMsg = readFile("${TF_DIR}/infracost.txt")
                        notifySlack("üí∞ *Infracost Report for ${ENV}:*\\n```\\n${costMsg}\\n```")
                    }
                }
            }
        }

        stage('üõë Manual Approval (PROD)') {
            when {
                allOf {
                    expression { params.TARGET_ENV == 'prod' }
                    expression { params.APPLY_INFRA }
                    expression { !params.DESTROY_INFRA }
                }
            }
            steps {
                input message: '‚ö†Ô∏è Approve PROD deployment?', ok: 'üöÄ Deploy'
            }
        }

        stage('‚ö° Apply (with rollback)') {
            when {
                allOf {
                    expression { params.APPLY_INFRA }
                    expression { !params.DESTROY_INFRA }
                }
            }
            steps {
                dir("${TF_DIR}") {
                    script {
                        def result = sh(script: "terraform apply -input=false tfplan", returnStatus: true)

                        if (result != 0) {
                            echo "‚ùå Apply failed."

                            if (params.ROLLBACK_ON_FAILURE) {
                                echo "üîÅ Running rollback (refresh-only)..."
                                sh """
                                    terraform apply -refresh-only -auto-approve \
                                        -var-file=${TF_VAR_FILE} || true
                                """
                                notifySlack("‚ö†Ô∏è Rollback executed for ${ENV}")
                            }

                            error("Terraform apply failed")
                        }
                    }
                }
            }
        }

        stage('üí£ Destroy Environment') {
            when { expression { params.DESTROY_INFRA } }
            steps {
                dir("${TF_DIR}") {
                    echo "üî• Destroying ${ENV} environment..."
                    sh "terraform destroy -auto-approve -var-file=${TF_VAR_FILE}"
                }
            }
        }
    }

    post {
        success {
            script { notifySlack("‚úÖ Terraform pipeline SUCCESS for ${env.ENV}") }
        }
        failure {
            script { notifySlack("‚ùå Terraform pipeline FAILED for ${env.ENV}") }
        }
        always {
            echo 'üßπ Cleaning workspace...'
            cleanWs()    // now safe (global agent keeps workspace alive)
        }
    }
}

def notifySlack(String message) {
    try {
        withCredentials([string(credentialsId: 'slack_webhook_url', variable: 'SLACK_URL')]) {
            sh """
                curl -X POST -H 'Content-Type: application/json' \
                    --data '{\"text\": \"${message}\"}' "${SLACK_URL}"
            """
        }
    } catch (e) {
        echo "Slack notification failed: ${e}"
    }
}
